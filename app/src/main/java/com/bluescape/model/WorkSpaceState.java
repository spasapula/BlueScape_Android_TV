package com.bluescape.model;

import android.content.Context;
import android.graphics.Color;
import android.net.Uri;
import android.opengl.GLSurfaceView;

import com.bluescape.AppConstants;
import com.bluescape.activity.BaseActivity;
import com.bluescape.model.widget.BaseWidgetModel;
import com.bluescape.model.widget.ImageModel;
import com.bluescape.model.widget.LocationMarkerModel;
import com.bluescape.model.widget.MoveModel;
import com.bluescape.model.widget.NoteModel;
import com.bluescape.model.util.Rect;
import com.bluescape.model.template.WidgetTemplate;
import com.bluescape.view.renderers.Renderer;
import com.bluescape.collaboration.socket.sender.VcMessageSender;
import com.bluescape.collaboration.socket.WebSocketClient;
import com.bluescape.view.util.TextureManager;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.Map;

/**
 * This is just to hold data until we design a better data structure
 * <p/>
 * Created by Mark Stanford on 11/20/14.
 */
public class WorkSpaceState {

    public int getGlobalOrder() {
        return mGlobalWorkSpaceEventOrder;
    }

    public int getAndIncrementOrder() {
        return mGlobalWorkSpaceEventOrder += 13;
    }

    /**
     * Instance holder for our safe lazy instantiation pattern
     * https://en.wikipedia.org/wiki/Initialization-on-demand_holder_idiom
     */
    private static class instanceHolder {
        private static final WorkSpaceState INSTANCE = new WorkSpaceState();
    }

    private static final String TAG = WorkSpaceState.class.getSimpleName();

    /**
     * Returns the singleton
     */
    public static WorkSpaceState getInstance() {
        return instanceHolder.INSTANCE;
    }

    public Context context;

    // Make this the drawable tree within the view port only and maintain the
    // history tree in mModelTree
    private final ModelTree mModelTree;

    public boolean mHistoryLoadCompleted = false;

    public WebSocketClient mWebSocketClient;

    // The surfaceView.Make sure we have a reference to this. Maintain this
    // state on surface changes etc.
    private GLSurfaceView mWorkspaceView = null;

    // Keep a reference to our renderer. Never know when you will need it
    private Renderer mRenderer = null;

    // boolean to see if Renderer is set in CustomGLView this is checked in the
    // the onPause and onResume of MainActivity in case notecard add etc. are
    // launched so we
    // dont have to recreate the CustomGLView every time
    public boolean mIsRendererSet = false;

    // The aspect ratio of the screen. This what we use to scale touches/drawing
    // etc. * This is generated by the renderer method ChangeProjection()
    private float mAspectRatio = 1f;
    // The zoom level
    private float mZoom = AppConstants.WORKSPACE_STATE_DEFAULT_ZOOM;

    // Max Zoom magic numbers
    private float mMaxZoom = AppConstants.WORKSPACE_STATE_DEFAULT_ZOOM / 4;
    private float mMinZoom = mMaxZoom * 20;

    // Current ViewPort in array format for simplicity. is this same as
    // mWorldPosition ?
    // public float mCurrentViewPort[];

    // Workspace offset
    private float offsetX = 0f;

    private float offsetY = 0f;

    // Our world space position for the background and ortho matrix
    private float[] mWorldPosition;

    private String mClientId;

    public BaseWidgetModel mCurrentSelectedBaseModel = null;

    public MoveModel mLastMoveModel = null;


    // The current line width for strokes
    private float mCurrentLineWidth = 500f;

    // Current drawable the user has selected to draw
    private int mCurrentTool = AppConstants.TOOL_NO_SHAPE;

    // The background_fragment.glsl the user currently has selected for drawing.
    private int mCurrentSelectedColor = Color.WHITE;

    // Keep track of the URI for the texture for the next Image Drawable
    private Uri mImageUri = null;

    // ImageReal Path when chosen from Gallery and Camera
    private String mImageRealPath = null;

    // Avoiding Setters and Getters for optimization
    public BaseActivity currentActivity;

    // Keep track of the baseName for the card we will create.
    private WidgetTemplate mTemplate = null;

    // Notemodel we store from the note builder dialog.
    public NoteModel mNoteModel;

    public ImageModel mImageModel;

    // Leaving mZOrder as the the Layer Constant because the touch and select
    // for gesture is dependent on it, introducing eventOrder and
    // global event order to track the order of events at workspace level as
    // mEventOrder in BaseWidgetModel and mGlobalWorkSpaceEventOrder in
    // WorkSpaceState
    // The z value set to LAYER constants default -10f for now. Setting default
    // now, each Model needs sets its own zOrder later
    // public float mGlobalWorkSpaceEventOrder = 1f;
    private int mGlobalWorkSpaceEventOrder = 1;

    // Store Ids of temporary StrokeModels to delete on receiving the message
    // from WS Server
    public ArrayList<String> mTempStrokeIds;

    private VcMessageSender viewportPositionMessageSender = new VcMessageSender();

    // Toolbar selected color
    private float[] mSelectedStrokeColor = AppConstants.StrokeColor.BRUSH_COLOR_WHITE;

    // Setting the WorkSpaceModel to explicitly to help in synchronization
    // between the threads
    private WorkSpaceModel mWorkSpaceModel;


    //Width of the Border for Activity Indicator
    private float mCurrentBorderWidth;

    //Width of the Initials for Activity Indicator
    private float mCurrentInitialsWidth;

    /**
     * Private constructor for our singleton pattern
     */
    private WorkSpaceState() {
        // mDrawableTree = DrawableTree.getInstance();
        mModelTree = new ModelTree(this);
        // mAnimationMap = new ConcurrentHashMap<>();

        // DrawableStateManager variables initialization
        // Local Stroke on CArd, image etc
        mCurrentSelectedColor = 255; // Blue
        // Main Activity Stroke
        mSelectedStrokeColor = AppConstants.StrokeColor.BRUSH_COLOR_LIGHT_BLUE;

    }

    // Called in GestureHandler for Scroll This adds to the offset
    public void addOffset(float[] offset) {
        this.offsetX += offset[0];
        this.offsetY += offset[1];

        this.mRenderer.updateViewport(mZoom, offsetX, offsetY);
        // Send the new VC to Web Socket Server
        sendVcWSServer();
    }

    // Called from Scale
    public void addToZoom(float difference) {
        // Make sure we can't add beyond the mins and maxes
        if (mZoom + difference < mMaxZoom || mZoom + difference > mMinZoom) {
            AppConstants.LOG(AppConstants.CRITICAL, TAG, "Zoom rejected mMaxZoom or mMinZoom reached " + "mZoom = " + mZoom + " Max: " + mMaxZoom
                    + " Min" + mMinZoom);
            return;
        }
        AppConstants.LOG(AppConstants.VERBOSE, TAG, "Zoom OK   mZoom = " + mZoom + "new mZoom =" + (this.mZoom + difference) + " Max: " + mMaxZoom
                + " Min" + mMinZoom);

        this.mZoom += difference;

        this.mRenderer.updateViewport(mZoom, offsetX, offsetY);

        AppConstants.LOG(AppConstants.VERBOSE, TAG, "Zoom OK  new mZoom = " + mZoom + " Max: " + mMaxZoom + " Min" + mMinZoom);

        // Send the new VC to Web Socket Server
        sendVcWSServer();

    }

    // Cleanup WorkspaceState on workspace exit
    public void cleanUpWorkSpaceStateOnExit() {
        mCurrentTool = AppConstants.TOOL_NO_SHAPE;
        mCurrentSelectedColor = 255; // Blue
        mModelTree.clear();
        mZoom = AppConstants.WORKSPACE_STATE_DEFAULT_ZOOM;
        mWebSocketClient.disconnect();
        mAspectRatio = 1f;
        offsetX = 0f;
        offsetY = 0f;
        mSelectedStrokeColor = AppConstants.StrokeColor.BRUSH_COLOR_WHITE;

        mHistoryLoadCompleted = false;
        mNoteModel = null;
        mGlobalWorkSpaceEventOrder = 1;
        mImageModel = null;

        mTempStrokeIds = null;
        mSelectedStrokeColor = AppConstants.StrokeColor.BRUSH_COLOR_LIGHT_BLUE;
        TextureManager.getInstance().clearTextureCache();
        mCurrentBorderWidth = 0f;
        mCurrentInitialsWidth = 0f;

    }

    public float getAspectRatio() {
        return mAspectRatio;
    }

    public String getClientId() {
        return mClientId;
    }


    public float getCurrentBorderWidth() {
        return mCurrentBorderWidth;
    }

    public float getCurrentInitialsWidth() {
        return mCurrentInitialsWidth;
    }

    public float getCurrentLineWidth() {
        return mCurrentLineWidth;
    }


    public int getCurrentSelectedColor() {
        return mCurrentSelectedColor;
    }

    /**
     * Get the current tool we have selected.
     */
    public int getCurrentTool() {
        return mCurrentTool;
    }

    public String getImageRealPath() {
        return mImageRealPath;
    }

    /**
     * Getters and setters to maintain the state of the object creation.
     */
    public Uri getImageUri() {
        return mImageUri;
    }

    public float getMaxZoom() {
        return mMaxZoom;
    }

    public float getMinZoom() {
        return mMinZoom;
    }

    public ModelTree getModelTree() {
        return mModelTree;
    }

    public float[] getOffset() {
        return new float[]{offsetX, offsetY};
    }

    public Renderer getRenderer() {
        return mRenderer;
    }

    public float[] getSelectedStrokeColor() {
        return mSelectedStrokeColor;
    }

    public WidgetTemplate getTemplate() {
        return mTemplate;
    }

    public WorkSpaceModel getWorkSpaceModel() {
        return this.mWorkSpaceModel;
    }

    public GLSurfaceView getWorkspaceView() {
        return mWorkspaceView;
    }

    public float[] getWorldPosition() {
        return mWorldPosition;
    }

    public float getZoom() {
        return mZoom;
    }


    public void setAspectRatio(float mAspectRatio) {
        this.mAspectRatio = mAspectRatio;
    }

    public void setClientId(String clientId) {
        mClientId = clientId;
    }

    public void setCurrentLineWidth(float lineWidth) {
        this.mCurrentLineWidth = lineWidth;
    }

    public void setCurrentBorderWidth(float borderWidth) {
        this.mCurrentBorderWidth = borderWidth;
    }

    public void setCurrentInitialsWidth(float initialsWidth) {
        this.mCurrentInitialsWidth = initialsWidth;
    }


    public void setCurrentSelectedColor(int mCurrentSelectedColor) {
        this.mCurrentSelectedColor = mCurrentSelectedColor;
    }

    /**
     * Set the current tool. @param mCurrentShapeToDraw
     */
    public void setCurrentTool(int mCurrentShapeToDraw) {
        this.mCurrentTool = mCurrentShapeToDraw;
    }

    public void setImageRealPath(String mImageRealPath) {
        this.mImageRealPath = mImageRealPath;
    }

    public void setImageUri(Uri imageUri) {
        mImageUri = imageUri;
    }

    public void setMaxZoom(float maxzoom) {
        mMinZoom = maxzoom * 10;
        mMaxZoom = maxzoom / 4;
    }

    // Called in MainActivity for LocationMarkers switching This sets the
    // offsets
    public void setOffset(float[] offset) {
        this.offsetX = offset[0];
        this.offsetY = offset[1];
        this.mRenderer.updateViewport(mZoom, offsetX, offsetY);
        // Send the new VC to Web Socket Server
        sendVcWSServer();
    }

    public void setOffsetX(float offsetX) {
        this.offsetX = offsetX;
    }

    public void setOffsetY(float offsetY) {
        this.offsetY = offsetY;
    }

    public void setRenderer(Renderer mRenderer) {
        this.mRenderer = mRenderer;
    }

    public void setSelectedStrokeColor(float[] mSelectedStrokeColor) {
        this.mSelectedStrokeColor = mSelectedStrokeColor;
    }

    public void setTemplate(WidgetTemplate template) {
        mTemplate = template;
    }

    public void setWorkSpaceModel(WorkSpaceModel workSpaceModel) {
        mWorkSpaceModel = workSpaceModel;
        mModelTree.setRoot(workSpaceModel);
    }

    public void setWorkspaceView(GLSurfaceView mWorkspaceView) {
        this.mWorkspaceView = mWorkspaceView;
    }

    public void setWorldPosition(float[] worldPosition) {
        this.mWorldPosition = worldPosition;
        // ((WorkSpaceDrawable)getWorkspaceDrawable()).setWorldPos(worldPosition);
        (getModelTree().root).setWorldPos(worldPosition);
    }

    public void setZoom(float mZoom) {
        this.mZoom = mZoom;
    }

    // Called from RlMessageHandler when historyLoad is complete no setting
    // mAreAllViewPortWidgetsInitialized
    // as initializeViewPortWidgets() is called after fullhistoryLoad that sets
    // it for the first time
    public void setZoomAndOffset(float mZoom, float offsetX, float offsetY) {
        this.mZoom = mZoom;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.mRenderer.updateViewport(mZoom, offsetX, offsetY);

        // Had to reset cos we get the RL message even when another person exits
        // the same workspace and causes issue with large or really small
        // markers
        // Send the new VC to Web Socket Server
        sendVcWSServer();
    }

    public void updateOrder(int objectOrder) {
        if (mGlobalWorkSpaceEventOrder < objectOrder) mGlobalWorkSpaceEventOrder = objectOrder;
    }

    private boolean sendVcWSServer() {
        viewportPositionMessageSender.send();
        return true;
    }

}
